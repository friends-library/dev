import fs from 'node:fs';
import exec from 'x-exec';
import type { Domain } from './types';

async function main(): Promise<void> {
  const domains: CodegenDomain[] = [new CodegenDomain(`dev`, `DevClient`)];

  const promises = domains.map(async (domain) => {
    domain.clean();
    const output = await domain.fetch();

    const sharedTypes = Object.keys(output.shared).sort();
    let sharedFile = Object.values(output.shared).join(`\n\n`);
    sharedFile = sortShared(spaced(sharedFile));
    fs.writeFileSync(
      `${domain.absPath}/shared.ts`,
      spaced(`// auto-generated, do not edit`, sharedFile),
    );

    const clientMethods: string[] = [];
    const pairIndexLines = [`export * from '../shared';`];

    for (const [pairName, { decl, fetcher }] of Object.entries(output.pairs)) {
      const shared: string[] = [];
      for (const typeName of sharedTypes) {
        const regex = new RegExp(`\\b${typeName}\\b`);
        if (
          decl.match(regex) &&
          !decl.includes(`'${typeName}'`) &&
          !decl.includes(`interface ${typeName}`)
        ) {
          shared.push(typeName);
        }
      }
      let sharedImport = ``;
      if (shared.length > 0) {
        sharedImport = `import type { ${shared.join(`, `)} } from '../shared';\n`;
      }
      fs.writeFileSync(
        `${domain.pairDir}/${pairName}.ts`,
        autogenerated(spaced(sharedImport, expand(decl))),
      );

      clientMethods.push(`public ${fetcher}`);
      pairIndexLines.push(`export * from './${pairName}';`);
    }

    fs.writeFileSync(
      `${domain.absPath}/${domain.clientName}.ts`,
      autogenerated(domain.clientFile(clientMethods.sort())),
    );

    fs.writeFileSync(
      `${domain.pairDir}/index.ts`,
      autogenerated(pairIndexLines.sort().join(`\n`)),
    );

    exec.exit(`${PRETTIER_FORMAT} ${domain.absPath}/*`);
  });
  await Promise.all(promises);
}

class CodegenDomain {
  public constructor(private domain: Domain, public clientName: string) {}

  public get absPath(): string {
    return `${__dirname}/../../../libs-ts/pairql/src/${this.domain}`;
  }

  public get pairDir(): string {
    return `${this.absPath}/pairs`;
  }

  public async fetch(): Promise<CodegenOutput> {
    const response = await fetch(`http://127.0.0.1:8080/codegen/${this.domain}`);
    try {
      const output = (await response.json()) as CodegenOutput;
      Object.entries(output.pairs).sort(([a], [b]) => b.localeCompare(a));
      Object.entries(output.shared).sort(([a], [b]) => b.localeCompare(a));
      return output;
    } catch (e) {
      console.error(e); // eslint-disable-line no-console
      process.exit(1);
    }
  }
  public clean(): void {
    exec(`rm -rf ${this.absPath}`);
    exec(`mkdir -p ${this.absPath}`);
    exec(`mkdir -p ${this.pairDir}`);
  }

  public clientFile(clientMethods: string[]): string {
    return DOMAIN_CLIENT.replace(/%CLIENT_NAME%/g, this.clientName)
      .trim()
      .replace(/%DOMAIN%/g, this.domain)
      .replace(/%ENDPOINTS%/g, clientMethods.join(`\n\n`));
  }
}

type CodegenOutput = {
  shared: Record<string, string>;
  pairs: Record<string, { decl: string; fetcher: string }>;
};

function autogenerated(file: string): string {
  return `// auto-generated, do not edit\n${file}`;
}

function spaced(...strings: string[]): string {
  return strings.join(`\n\n`);
}

function expand(paircode: string): string {
  return paircode.replace(/Array<{ /g, `Array<{\n`).replace(/{ /g, `{\n`);
}

function sortShared(code: string): string {
  const parts = code.split(`\n\n`).map((chunk) => {
    const lines = chunk.split(`\n`);
    const firstLine = lines[0] ?? ``;
    const typeName = firstLine.replace(/export (:?type|interface|enum) ([^ ]+) .*/, `$2`);
    return { typeName, chunk };
  });
  parts.sort((a, b) => a.typeName.localeCompare(b.typeName));
  return parts.map((p) => p.chunk).join(`\n\n`);
}

const PRETTIER_FORMAT = [
  `${__dirname}/../../../node_modules/.bin/prettier`,
  `--config`,
  `${__dirname}/../../../.prettierrc.json`,
  `--write`,
].join(` `);

main();

const DOMAIN_CLIENT = `
import type { Env } from '../types';
import type Result from '../Result';
import type * as P from './pairs';
import Client from '../Client';

export default class %CLIENT_NAME% extends Client {
  public constructor(env: Env, getToken: () => string | undefined) {
    super(env, \`%DOMAIN%\`, getToken);
  }

  public static node(
    process: { argv: string[]; env: Record<string, string | undefined> },
    pattern?: string | undefined,
  ): %CLIENT_NAME% {
    return Client.inferNode(%CLIENT_NAME%, process, pattern);
  }

  public static web(href: string, getToken: () => string | undefined): %CLIENT_NAME% {
    return Client.inferWeb(%CLIENT_NAME%, href, getToken);
  }

  %ENDPOINTS%
}
`;
