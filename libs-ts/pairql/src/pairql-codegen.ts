import fs from 'node:fs';
import exec from 'x-exec';
import type { Domain } from './types';

async function main(): Promise<void> {
  const domains: CodegenDomain[] = [
    new CodegenDomain(`dev`, `DevClient`, true),
    new CodegenDomain(`admin`, `AdminClient`, false),
    new CodegenDomain(`order`, `OrderClient`, false),
    new CodegenDomain(`evans-build`, `EvansBuildClient`, true),
    new CodegenDomain(`evans`, `EvansClient`, false),
  ];

  const promises = domains.map(async (domain) => {
    domain.clean();
    const output = await domain.fetch();

    const sharedTypes = Object.keys(output.shared).sort();

    const clientMethods: string[] = [];
    const pairIndexLines: string[] = [];

    if (sharedTypes.length > 0) {
      pairIndexLines.push(`export * from '../shared';`);
      let sharedFile = Object.values(output.shared).join(`\n\n`);
      sharedFile = sortShared(spaced(sharedFile));
      fs.writeFileSync(
        `${domain.absPath}/shared.ts`,
        spaced(`// auto-generated, do not edit`, sharedFile),
      );
    }

    for (const [pairName, pair] of Object.entries(output.pairs)) {
      const shared: string[] = [];
      for (const typeName of sharedTypes) {
        const regex = new RegExp(`\\b${typeName}\\b`);
        if (
          pair.decl.match(regex) &&
          !pair.decl.includes(`'${typeName}'`) &&
          !pair.decl.includes(`interface ${typeName}`)
        ) {
          shared.push(typeName);
        }
      }
      let sharedImport = ``;
      if (shared.length > 0) {
        sharedImport = `import type { ${shared.join(`, `)} } from '../shared';\n`;
      }
      fs.writeFileSync(
        `${domain.pairDir}/${pairName}.ts`,
        autogenerated(spaced(sharedImport, expand(pair.decl))),
      );

      if (domain.addUnwrapMethods) {
        clientMethods.push(unwrapFetcher(pair));
        clientMethods.push(resultFetcher(pair, `both`));
      } else {
        clientMethods.push(resultFetcher(pair, `onlyResult`));
      }

      pairIndexLines.push(`export * from './${pairName}';`);
    }

    fs.writeFileSync(
      `${domain.absPath}/${domain.clientName}.ts`,
      autogenerated(domain.clientFile(clientMethods.sort())),
    );

    fs.writeFileSync(
      `${domain.pairDir}/index.ts`,
      autogenerated(pairIndexLines.sort().join(`\n`)),
    );

    exec.exit(`${PRETTIER_FORMAT} ${domain.absPath}/*`);
  });
  await Promise.all(promises);
}

class CodegenDomain {
  public constructor(
    private domain: Domain,
    public clientName: string,
    public addUnwrapMethods: boolean,
  ) {}

  public get absPath(): string {
    return `${__dirname}/../../../libs-ts/pairql/src/${this.domain}`;
  }

  public get pairDir(): string {
    return `${this.absPath}/pairs`;
  }

  public async fetch(): Promise<CodegenOutput> {
    const response = await fetch(`http://127.0.0.1:8080/codegen/${this.domain}`);
    try {
      const output = (await response.json()) as CodegenOutput;
      Object.entries(output.pairs).sort(([a], [b]) => b.localeCompare(a));
      Object.entries(output.shared).sort(([a], [b]) => b.localeCompare(a));
      return output;
    } catch (e) {
      console.error(e); // eslint-disable-line no-console
      process.exit(1);
    }
  }
  public clean(): void {
    exec(`rm -rf ${this.absPath}`);
    exec(`mkdir -p ${this.absPath}`);
    exec(`mkdir -p ${this.pairDir}`);
  }

  public clientFile(clientMethods: string[]): string {
    return DOMAIN_CLIENT.replace(/%CLIENT_NAME%/g, this.clientName)
      .trim()
      .replace(/%DOMAIN%/g, this.domain)
      .replace(/%ENDPOINTS%/g, clientMethods.join(`\n\n`));
  }
}

type CodegenPair = {
  decl: string;
  resultFetcher: string;
  unwrappedFetcher: string;
  fnNameCamel: string;
  fnNamePascal: string;
};

type CodegenOutput = {
  shared: Record<string, string>;
  pairs: Record<string, CodegenPair>;
};

function resultFetcher(pair: CodegenPair, context: 'onlyResult' | 'both'): string {
  return (
    `public ` +
    pair.resultFetcher.replace(
      `__FN_NAME__`,
      context === `onlyResult` ? pair.fnNameCamel : `${pair.fnNameCamel}Result`,
    )
  );
}

function unwrapFetcher(pair: CodegenPair): string {
  return `public ` + pair.unwrappedFetcher.replace(`__FN_NAME__`, pair.fnNameCamel);
}

function autogenerated(file: string): string {
  return `// auto-generated, do not edit\n${file}`;
}

function spaced(...strings: string[]): string {
  return strings.join(`\n\n`);
}

function expand(paircode: string): string {
  return paircode.replace(/Array<{ /g, `Array<{\n`).replace(/{ /g, `{\n`);
}

function sortShared(code: string): string {
  const parts = code.split(`\n\n`).map((chunk) => {
    const lines = chunk.split(`\n`);
    const firstLine = lines[0] ?? ``;
    const typeName = firstLine.replace(/export (:?type|interface|enum) ([^ ]+) .*/, `$2`);
    return { typeName, chunk };
  });
  parts.sort((a, b) => a.typeName.localeCompare(b.typeName));
  return parts.map((p) => p.chunk).join(`\n\n`);
}

const PRETTIER_FORMAT = [
  `${__dirname}/../../../node_modules/.bin/prettier`,
  `--config`,
  `${__dirname}/../../../.prettierrc.json`,
  `--write`,
].join(` `);

main();

const DOMAIN_CLIENT = `
import type { Env } from '../types';
import type Result from '../Result';
import type * as P from './pairs';
import Client from '../Client';

export default class %CLIENT_NAME% extends Client {
  public constructor(env: Env, getToken: () => string | undefined) {
    super(env, \`%DOMAIN%\`, getToken);
  }

  public static node(
    process: { argv: string[]; env: Record<string, string | undefined> },
    pattern?: string | undefined,
  ): %CLIENT_NAME% {
    return Client.inferNode(%CLIENT_NAME%, process, pattern);
  }

  public static web(href: string, getToken: () => string | undefined): %CLIENT_NAME% {
    return Client.inferWeb(%CLIENT_NAME%, href, getToken);
  }

  %ENDPOINTS%
}
`;
