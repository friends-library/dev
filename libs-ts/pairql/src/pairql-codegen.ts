import fs from 'node:fs';
import exec from 'x-exec';
import type { Domain } from './types';

async function main(): Promise<void> {
  const domains: CodegenDomain[] = [new CodegenDomain(`dev`, `DevClient`)];

  const promises = domains.map(async (domain) => {
    domain.clean();
    const output = await domain.fetch();
    const clientMethods: string[] = [];
    const pairIndexLines: string[] = [];
    for (const [pairName, { decl, fetcher }] of Object.entries(output.pairs)) {
      fs.writeFileSync(`${domain.pairDir}/${pairName}.ts`, autogenerated(decl));
      clientMethods.push(`public ${fetcher}`);
      pairIndexLines.push(`export * from './${pairName}';`);
    }
    fs.writeFileSync(
      `${domain.absPath}/${domain.clientName}.ts`,
      autogenerated(domain.clientFile(clientMethods)),
    );
    fs.writeFileSync(
      `${domain.pairDir}/index.ts`,
      autogenerated(pairIndexLines.join(`\n`)),
    );
    exec.exit(`${PRETTIER_FORMAT} ${domain.absPath}/*`);
  });
  await Promise.all(promises);
}

class CodegenDomain {
  public constructor(private domain: Domain, public clientName: string) {}

  public get absPath(): string {
    return `${__dirname}/../../../libs-ts/pairql/src/${this.domain}`;
  }

  public get pairDir(): string {
    return `${this.absPath}/pairs`;
  }

  public async fetch(): Promise<CodegenOutput> {
    const response = await fetch(`http://127.0.0.1:8080/codegen/${this.domain}`);
    try {
      const output = (await response.json()) as CodegenOutput;
      Object.entries(output.pairs).sort(([a], [b]) => b.localeCompare(a));
      Object.entries(output.shared).sort(([a], [b]) => b.localeCompare(a));
      return output;
    } catch (e) {
      console.error(e); // eslint-disable-line no-console
      process.exit(1);
    }
  }
  public clean(): void {
    exec(`rm -rf ${this.absPath}`);
    exec(`mkdir -p ${this.absPath}`);
    exec(`mkdir -p ${this.pairDir}`);
  }

  public clientFile(clientMethods: string[]): string {
    return DOMAIN_CLIENT.replace(/%CLIENT_NAME%/g, this.clientName)
      .trim()
      .replace(/%DOMAIN%/g, this.domain)
      .replace(/%ENDPOINTS%/g, clientMethods.join(`\n\n`));
  }
}

type CodegenOutput = {
  shared: Record<string, string>;
  pairs: Record<string, { decl: string; fetcher: string }>;
};

// function expand(decl: string): string {
//   return decl.replace(/Array<{ /g, `Array<{\n`).replace(/{ /g, `{\n`);
// }

function autogenerated(file: string): string {
  return `// auto-generated, do not edit\n${file}`;
}

const PRETTIER_FORMAT = [
  `${__dirname}/../../../node_modules/.bin/prettier`,
  `--config`,
  `${__dirname}/../../../.prettierrc.json`,
  `--write`,
].join(` `);

main();

const DOMAIN_CLIENT = `
import type { Env } from '../types';
import type Result from '../Result';
import type * as P from './pairs';
import Client from '../Client';

export default class %CLIENT_NAME% extends Client {
  public constructor(env: Env, getToken: () => string | undefined) {
    super(env, \`%DOMAIN%\`, getToken);
  }

  public static node(
    process: { argv: string[]; env: Record<string, string | undefined> },
    pattern?: string | undefined,
  ): %CLIENT_NAME% {
    return Client.inferNode(%CLIENT_NAME%, process, pattern);
  }

  public static web(href: string, getToken: () => string | undefined): %CLIENT_NAME% {
    return Client.inferWeb(%CLIENT_NAME%, href, getToken);
  }

  %ENDPOINTS%
}
`;
